package io.semla.datasource;

import io.semla.config.HsqlDatasourceConfiguration;
import io.semla.model.EntityModel;
import io.semla.query.Pagination;
import io.semla.query.Predicates;
import org.jdbi.v3.core.Jdbi;

import javax.persistence.Embedded;
import javax.persistence.GeneratedValue;
import java.util.UUID;
import java.util.stream.Collectors;

import static io.semla.reflect.Types.isAssignableTo;
import static io.semla.reflect.Types.isAssignableToOneOf;


public class HsqlDatasource<T> extends SqlDatasource<T> {

    public HsqlDatasource(EntityModel<T> entityModel, Jdbi dbi, String tablename) {
        super(entityModel, dbi, tablename);
    }

    @Override
    protected void extend() {
        if (model().key().member().annotation(GeneratedValue.class).isPresent()) {
            if (!model().key().columnDefinition().isPresent() && isAssignableToOneOf(model().key().member().getType(), Integer.class, Long.class)) {
                String columnDefinition = ddl().getColumnDefinition(model().key())
                    .orElseThrow(() -> new IllegalStateException("no definition for column " + model().key()));
                columnDefinition += " GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1) NOT NULL";
                ddl().withColumnDefinition(model().key()::equals, columnDefinition);
            }
        }
        ddl()
            .withColumnDefinition(column -> isAssignableTo(column.member().getType(), Boolean.class), "BOOLEAN")
            .withColumnDefinition(column -> column.member().annotation(Embedded.class).isPresent(), "CLOB")
            .withColumnDefinition(column -> column.member().getType().equals(UUID.class), "VARCHAR(36)");

        model().indices().forEach(index -> {
                if (index.isPrimary()) {
                    ddl().withConstraint("PRIMARY KEY (" + index.columnNames(ddl().escape()) + ")");
                } else {
                    ddl().addCommand("CREATE " + (index.isUnique() ? "UNIQUE " : "")
                        + "INDEX " + ddl().escape(ddl().tablename() + "_" + index.name())
                        + " ON " + ddl().escape(ddl().tablename())
                        + " (" + index.columnNames(ddl().escape()) + ")");
                }
            }
        );
    }

    public static HsqlDatasourceConfiguration configure() {
        return new HsqlDatasourceConfiguration();
    }

    @Override
    public long delete(Predicates<T> predicates, Pagination<T> pagination) {
        if (pagination.isSorted() || pagination.isPaginated()) {
            //Hsql doesn't supported sorting or offset on deletes
            return delete(list(predicates, pagination).stream().map(model().key().member()::getOn).collect(Collectors.toList()));
        }
        return super.delete(predicates, pagination);
    }
}

